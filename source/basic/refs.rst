Ссылки. Ссылочные типы
================
КАк мы изучили ранее, в python есть массивы и словари. Более того, мы можем
создать массив словарей, который содержит массивы словарей за каждым своим
ключем. Такие данные могут занимать "много" памяти. Много с точки зрения
программирования - килобайты, мегабайты. При этом в языке приходится решить
следующий вопрос. Допустим, в одном месте мы создаем какой-то массив данных, а
использовать его собираемся в другом, там, где первое место не видно::

   def create_data():
      payload = []
      for i in range(1000):
         ints = []
         floats = []
         for i in range(10000):
            ints.append(i)
            floats.append(i + 0.15)
         payload.append({"ints": ints, "floats": floats})
      return payload

Прикинем размер:
1000 раз мы создаем 2 массива по 10000 int(4 байта) + float(4 байта)::

   (1000 * (10000 * (4 + 8))) / 1024 / 1024

В конце делим 2 раза на 1024, чтобы получить из байт мегабайты.
И того, получилось 100Мб. Если попробовать скопировать файл такого размера с
одного жеского диска на другой, то это может занять пару секунд. Что такое пара
секунд, это же не долго.

Но пройдем немного дальше::

   def process_data(payload):
      for data in payload:
         pass # тут выполняем например фильтрацию, сортировку
      return payload

И на финал, где все это работает::

   def main():
      data = create_data()
      new_data = process_data(data)
      print(new_data)

Видно что мы отдаем `data` в функцию `process_data`. Как это можно сделать,
если бы мы придумывали язык?
Наиболее простых видится 2 варианта:

1. Скопировать
2. Передать функции "ссылку" или адрес этих данных.

Если мы будем делать копирование, то в функции `main` мы его сделаем 4 раза:
1. из функции `create_data` мы скопируем в `data`
2. из `data` в `process_data`
3. из `process_data` в `new_data`
4. из `new_data` в `print`

Есл копирование займет 2 секунды, то это превратится в программу, которая
делает это 2*4 = 8 секунд. А если данных будет в 10 раз больше? К тому же я не
считаю время, необходимое на обработку этих данных, но не в этом суть: мы
просто на копировании теряем 8 секунд. Программа ничего не делает, но трати
время.

Решить эту проблему помогут ссылки. Ссылка, это адрес данных. Когда мы создаем
данные, то для потенциально больших блоков данных, мы можем отдавать в "язык"
не сами данные как есть, а только ссылку на них. Т.е. в нашем примере, в
переменой `data` будет лежать адрес, который сам по себе займет всего 4-8 байт.
И тогда мы будем передавать его и его же копировать. Таким образом мы сократили
затраты на копиравание многократно.

Но с ссылками есть один нюанс. Рассмотрим пример::

   source = { "a": 12 }
   item = source
   item['a'] = 52
   source['a']

После выполнения, можно увидеть что значение в словаре `source` поменялось.
Однако меняли мы `item`. Это означает, что `item` и `source` содержат один и
тот же адрес (мы это сделали написав `item = source`) и и любые действия с
`item`, это все равно что действия с `source`.

Учитывая это, мы можем переписать нашу функцию `process_data`::

   def process_data(payload):
      for data in payload:
         pass  # тут выполняем например фильтрацию, сортировку
      # ничего не возвращаем, т.к. мы работали со ссылкой и меняли данные по
      # этой ссылке

   def main():
      data = create_data()
      process_data(data)
      print(data)

Код немного упростился.

Ссылками являются все переменные, значение которые не примитивы(целые числа,
дробные, строки, булево, `None`). Ссылками являются составные типы (массивы,
словари) и другие объекты, о которых мы поговорим в части про
объекто-ориентированное программирование.
